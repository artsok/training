https://habr.com/ru/company/yandex/blog/353834/ - Советы по созданию приложений к окончанию набора в Школу мобильной разработки Яндекса


Лекция №1
Часть 1:
1. Java Virtual Machine называется HotSpot.
*.java -> *.class -> jar -> далее запускаем в виртуальной машине JVM (HotSpot)
Все прогаммы проходят этап прекомпиляции JIT-Compile, происходит оптимизация

Dalvik runtime flow
*.java -> *.class -> *.dex -> *.odex (dex compiler) в Gradle таска DEX-transform ->  *.apk -> запуск в Dalvik Runtime

Но в API 19 (KitKat) вышла новая версия ART (Android RunTime)
ART не учитывает шаг оптимизации DEX,

*.java -> *.class -> *.dex (dex compiler) -> *.apk -> и файл направляется процессу dex2oat (*.elf = executable link file) -> что-то промежуточное между машинным кодом и байт кодом скармливается ART VM


2. Управление памятью
Рассказ, что очистка идет от Root контекста. Если от рут контекста не можем достучаться до объекта, то он удаляется из памяти.

Виды GC:
1) GC_CONCURRENT - приостанавливает работу приложения, запускает отдельный thread сборщика и отработав выдает, сколько времени занял процесс сборки.
2) GC_EXPLICIT - сами в ручную вызываем сбоку памяти, обратившись к System.gc(), можно через различные debug тулзы очистить память.
3) GC_EXTERNAL_MALLOC - depreceted.
4) GC_FOR_MALLOC - не хватает хипа для своих задач???
5) GC_HPROF_DUMP_HEAP - когда хотим снять damp памяти, вызывается GC c флагом HPROF_DUMP, не позволяет самому себе вычищать память;

Не надо их запускать в ручную!
System.gc()
Runtime.getRuntime().gc() -> появился в ART;

В Android запускается гораздо чаще чем должен и работает быстрее чем в десктопной Java.

3. Внутренний классы
Автор призывает так не использовать
public class Main {
    public class Sub {
    }
}

Что происходит на самом деле, если собрать проект?
Внутренний класс Sub, хранит ссылку на внешний класс и инстанцируется, только если есть инстанс внешнего класса.

Вложенные классы лучше делать static.

Лямбда - в функцию передается кусок кода, который будет вызван когда нам потребуется на основе (invoke dynamic).


Грабли:
1) Версия Java может не совпадать с тем, что вы видите в студии. Вы можете педалить на 8 джаве, на устройстве у вас 6-ая.
2) Читать внимательно Java API, так как не всегда все методы есть из Java
3) Если используются хитрые штуки, то надо лучше проверять байткод!
!! Директория со всеми пред-скомпилированными классами: /app/build/intermediates/classes

Часть 2 (Подкапотная магия и дебаггеры)

JNI - механизм, который позволяет общаться в Java с низкоуровневым кодом (C,C++).
В android все тоже самое, только все shared библиотеки и т.д упаковывается в APK.
+
Поставляется все одним модулем и не надо переживать, что у пользователя, чего-то не будет.

-
Плохо, потому-что не можем, что нибудь подгрузить из вне.

Автор расказывает о JNI и как можно слинковать методы C++ c Java.
(link - 001.Школа мобильной разработки_JNI.png)

Особенности:
1) Все native методы работают в UI-потоке. Повесят ваше приложение, если напрямую начнете стучаться в C++;
Как обойти:
- Выкидываем в бэкграунд

2) Тяжелый биндинг методов
(link - 001.Школа мобильной разработки-JNI_LOAD.png)
Загрузили нашу библиотеку, когда она загрузилась у нас вызвался JNI_OnLoad, произошла загрузка всех базовых классов, если у нас это
плюсы и в Java мы дергаем native метод, он падает не в сам метод на прямую, как может показаться некоторым, он падает в JNI_wrapper.


 